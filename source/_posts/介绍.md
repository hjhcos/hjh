## 前端



### HTML

#### small

副标签

```html
<h4>
    比small大一号的字
    <small>比h4小一号的字</small>
</h4>
```



#### from

##### 指定url

`action: ""` 

- 不赋予值，默认为当前 url 的参数

```html
<form action="" method="post">
	<p>username:<input type="text" name="username" class="form-control"></p>
	<p>password:<input type="password" name="password" class="form-control"></p>
	<input type="submit" class="btn btn-success btn-block">
</form>

假如这段代码在你自己本地的 http://127.0.0.1:8000/login 网址里面，那么点击提交按钮参数会接在这个网址后面 http://127.0.0.1:8000/login/?username=&password=
```

- 只写后缀，当前网站域名接后缀

```html
<form action="/user" method="post">
	<p>username:<input type="text" name="username" class="form-control"></p>
	<p>password:<input type="password" name="password" class="form-control"></p>
	<input type="submit" class="btn btn-success btn-block">
</form>

假如这段代码在你自己本地的 http://127.0.0.1:8000/login 网址里面，那么点击提交按钮参数会接在你的另一个网址后面 http://127.0.0.1:8000/user/?username=&password=
```

- 指定网站域名，参数赋给指定域名

```html
<form action="https://hjhcos.cn/login" method="post">
	<p>username:<input type="text" name="username" class="form-control"></p>
	<p>password:<input type="password" name="password" class="form-control"></p>
	<input type="submit" class="btn btn-success btn-block">
</form>

假如这段代码在你自己本地的 http://127.0.0.1:8000/login 网址里面，那么点击提交按钮参数会跳转到另一网站后面 https://hjhcos.cn/login/?username=&password=
```

##### 上传文件

- `method` 必须为 `post` 
- `enctype` 必须为 `multipart/form-data` 

- `type` 设置为 `file`

  ```html
  <form action="" method="post" enctype="multipart/form-data">
  	<p>上传文件:<input type="file" name="file"></p>
  	<input type="submit">
  </form>
  ```

  

### CSS



### JavaScript



### Bootstrap







## 数据库

### 后端数据库加载

#### 基于 mysql-connector 模块

```py
from mysql.connector import connect

config = {
    'host': 'localhost',
    'user': 'root',
    'password': 'cos123456@',
    'database': 'data_db'
}

server = connect(**config)
# [{'Database': 'cos_db'}, {'Database': 'data_db'},...]
cursor = server.cursor(buffered=True, dictionary=True)
ddl = 'show databases;'
cursor.execute(ddl)
res = cursor.fetchall()
```

#### 基于 pymysql 模块

```py
import pymysql

server = pymysql.connect(
    host='127.0.0.1',
    port=3306,
    user='root',
    password='cos123456@',
    db='user',
    charset='utf8',
    autocommit=True
)
# pymysql.cursors.DictCursor指定数据返回格式 dict
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
dll = 'select * from userinfo'
affect_row = cursor.execute(dll)
data_list = cursor.fetchall()
```



## 软件开发架构

1. cs架构
2. bs架构



|   协议    | 数据传输 |
| :-------: | :------: |
|   HTTP    |   明文   |
|   HTTPS   |   密文   |
| websocket |   密文   |

- 四大特性

  1. 基于请求响应
  2. 基于TCP IP作用于应用层之上的协议
  3. 无状态
  4. 无连接

- 数据格式

  1. 请求首行
  2. 请求头
  3. 请求体

- 响应状态码

  1. 1xx		

  2. 2xx      200

  3. 3xx     

  4. 4xx      403     404

  5. 5xx      500

TCP协议

```
三次握手: SYN SYN/ACK ACK
四次挥手: FIN ACK FIN ACK
```

OSI七层

IP协议 以太网协议 ARP协议...



## 手写简易web框架



### 基于 socket 模块

```py
import socket
server = socket.socket()
server.bind(('127.0.0.1', 8080))
server.listen(5)        # 池 ...

while True:
    conn, addr = server.accept()
    data = conn.recv(1024)
    data = data.decode('utf-8')
    conn.send(b'HTTP/1.1 200 OK\r\n\r\n')
    current = data.split(' ')[1]
    if current == '/index':
        conn.send(b'index...')
    else:
        conn.send(b'Hello web!')
    conn.close()
```

`ps:`

1. 代码重复
2. 并发的问题
3. 手动处理 http 格式的数据



### 基于 flask 模块

```py
import flask

app = flask.Flask(__name__)


@app.route('/')
def index():
	return 'index...'


@app.route('/hello/<name>')
def hello(name=None):
	return 'hello %s' % (name)
	
# host='0.0.0.0' port=80 可以让外网访问
app.run(host='127.0.0.1', port=8080)
```



### 基于 wsgiref 模块

```py
from wsgiref.simple_server import make_server
```

`定义与url相对应的函数`

视图函数 views.py

```py
def error():
    return '404 page not found!'


def index():
    return 'index...'


def login():
    return 'login...'
```

路由与视图函数对应关系 urls.py

```py
urls = {
    '/index': index,
    '/login': login,
}
```

执行函数

```py
def run(env, response):
    """
    :param env: 请求相关的所有数据
    :param response: 响应相关的所有数据
    :return: 返回给浏览器的数据
    """
    response('200 OK', [])
    # 响应首行 响应头
    current = env.get('PATH_INFO')

    # if current == '/index':
    #     return [b'index...']
    # else:
    #     return [b'404 page not found!']
    try:
        func = urls[current]
    except Exception as e:
        func = error

    # 字节问题(b'') 二进制 ascii 不显示中文

    return [func().encode('utf-8')]
```

实时监听127.0.0.1:8080地址，只要有客户端连接，就交给 `run` 函数处理。

```py
server = make_server('127.0.0.1', 8080, run)
```

启动服务端

```py
server.serve_forever()
```

​	127.0.0.1 - - [10/Dec/2020 20:04:39] "GET /index HTTP/1.1" 200 8
​	127.0.0.1 - - [10/Dec/2020 20:04:39] "GET /favicon.ico HTTP/1.1" 200 19



### 动静态网页

```py
"""
静态网页
	页面上的数据是固定不变的
动态网页
	数据是实时获取
	eg:
		1. 后端获取当前时间展示到html页面上
		2. 数据是从数据库中获取的展示到html页面上
"""
```

#### 动态网页制作

`index.html` 

```py
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>get_time</title>
</head>

	<body>
    	<h1>当前时间</h1>
	</body>

</html>
```

`urls.py` 

```py
from views import *

urlpatterns = {
    '/get_time': get_time,
}
```

`views.py` 

```py
def get_time():
    with open(r'templates\index.html', 'r', encoding='utf-8') as f:
        data = f.read()
        current_time = datetime.now().strftime('%Y-%m-%d %X')
        data = data.replace('当前时间', current_time)

    return data
```

`main.py` 

```py
from wsgiref.simple_server import make_server
from urls import urlpatterns


def error():
    return '404 page not found!'


def run(env, response):
    response('200 OK', [])
    current = env.get('PATH_INFO')
    try:
        func = urlpatterns[current]
    except Exception as e:
        func = error
    return [func().encode('utf-8')]
    

server = make_server('127.0.0.1', 8080, run)
server.serve_forever()
```

运行 `main.py` ，打开浏览器输入 http://127.0.0.1:8080/get_time ，就可以通过刷新页面实时获取当前时间。



#### 模板引擎 jinja2 模块

```py
from jinja2 import Template
```

`views.py` 

```py
def get_user():
    user_dic = {
        'username': 'hjh',
        'age': 18
    }
    with open(r'templates\user.html', 'r', encoding='utf-8') as f:
    data = f.read()
    tem = Template(data)
    res = tem.render(user=user_dic)
    return res
```

`user.html` 

```py
{{ user }}
{{ user.age }}

{% for user_dict in user %}
	<tr>
		<tb> {{ user_dict.id }} </tb>
		<tb> {{ user_dict.username }} </tb>
		<tb> {{ user_dict.password }} </tb>
		<tb> {{ user_dict.hobby }} </tb>
	</tr>
{% endfor %}
```



## web框架

A: socket部分

B: 路由与视图函数对应关系

C: 模板语言



### Tornado

> [Tornado](https://www.tornadoweb.org/) 是一个Python web框架和异步网络库
>
> 使用非阻塞网络I/O
>
> A B C 都是自己写的



### Flask

> [Flask](https://dormousehole.readthedocs.io/en/latest/#) 是一个微型的 Python 开发的 Web 框架，基于Werkzeug WSGI工具箱和Jinja2 模板引擎
>
> 轻量级
>
> A  werkzeug(内部是wsgiref)
>
> B 自己写的
>
> C jinja2



### [Django](https://yiyibooks.cn/xx/Django_1.11.6/index.html)

> [Django](https://yiyibooks.cn/xx/Django_1.11.6/index.html) 是一个开放源代码的 Web 应用框架
>
> A： wsgiref
>
> B、C： 自己写的



#### 安装 

---

| Django version |            Python version             |
| :------------: | :-----------------------------------: |
|      1.11      | 2.7, 3.4, 3.5, 3.6, 3.7 (1.11.17添加) |

```py
pip install django==1.11.11

ps:
	如果安装出现问题可以重新安装
```



#### 创建项目

---

```py
django-admin startproject projectname

projectname/			项目
    
    mysite/				项目容器
        __init__.py
        settings.py		Django 项目的配置文件
        urls.py			Django 项目的 URL 声明  路由与视图函数对应关系 路由层
        wsgi.py			wsgiref模块
    db.sqlite3			自带小型数据库
    
    templates/			存放模板文件 html(Pycharm自动生成 需要手动创建)

ps:
	手动添加 templates 需要在 setting.py 文件里面配置一下路径
	在 TEMPLATES 变量里面设置 'DIRS' 的属性值
	'DIRS': [
		os.path.join(BASE_DIR, 'templates'), 
	]
```

建议：使用Pycharm专业版创建Django



#### 开启服务器

---

```py
 python manage.py runserver
```

在本地测试，只有开启服务器才能通过本地地址 `http://127.0.0.1:8000` 进行访问。



#### 创建应用

---

```py
python manage.py startapp appname

appname/
	migrations/			数据库迁移记录
        __init__.py
    __init__.py
    admin.py			Django 后台管理
    apps.py				注册使用
    models.py			数据库相关 模型层
    tests.py			测试文件
    views.py			视图函数 视图层
```



#### 删除应用

---

- 从 `INSTALLED_APPS` 中删除应用程序
- 删除该应用程序中模型的任何数据库表（请参见数据库中的 `app_name_model_name` ）
- 检查其他应用程序中的任何导入（可能是它们正在从该应用程序导入代码）
- 检查模板是否正在使用该应用程序的任何模板标记（如果该应用程序不再存在，则会产生错误）
- 检查您的设置文件，查看您是否没有使用来自该应用程序的任何代码
- 检查应用程序的任何静态内容是否在其他应用程序中使用
- 完全删除应用程序目录



#### 注册应用

---

在项目容器的 `settings.py` 文件里面，对创建的应用进行注册，这样我们才能真正意义上，使用这个应用功能块。

```py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'appname.apps.AppnameConfig',       # appname 为你创建应用的名字
    'appname'							# 也可以简写
]
```

每创建一个应用都需要在这个文件里面进行注册。



#### 创建视图函数

---

项目容器下不存在 `views.py` 文件，只有你创建的每个应用拥有独自的 `views.py` 。

```py
from django.shortcuts import render


def index(request):
	...
```



**三种在浏览器显示内容的方法**

##### render 

> 将给定的**模板**与给定的**上下文字典**组合，并使用该呈现的文本返回一个 `HttpResponse` 对象。
>

```py
from django.shortcuts import render


def index(request):

    # print(request)    # <WSGIRequest: GET '/index/'>
    return render(request, 'index.html')
```

我们可以**动态加载**HTML文件里面的数据。

```py
# print(request)    # <WSGIRequest: GET '/index/'>
user = {'姓名': 'cos', '年龄': 18}
return render(request, 'index.html', {'data': user})
```

`'data' ` 代表与HTML里面两个大括号 `{{  }}` 里面的**参数名一致**，例如下面代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>index</title>
</head>
<body>
{{ data }}
</body>
</html>
```

`user` 代表传递的参数。

那么你定义的变量 `user` 会指定赋值给HTML的两个大括号里面为 `data` 的参数名。

```py
return render(request, 'index.html', locals())
```

`locals()` 代表当前视图函数里面的所有参数。

##### HttpResponse

> 以字符串作为内容的HTTP响应类，可以读取、追加或替换的内容。
>

```py
from django.shortcuts import render, HttpResponse


def index(request):

	# print(request)    # <WSGIRequest: GET '/index/'>
    # return render(request, 'index.html')
	return HttpResponse(b'Access the characters displayed by index')
```

##### redirect

> 接受一个URL参数，表示让浏览器跳转去指定的URL。

```py
from django.shortcuts import render, HttpResponse, redirect


def index(request):

    print(request)    # <WSGIRequest: GET '/index/'>
    # return render(request, 'index.html')
    # return HttpResponse(b'Access the characters displayed by index')
    return redirect('https://www.baidu.com')		# redirect('/home/')

ps:
	访问 http://127.0.0.1:8000/index
	会转到 https://baidu.com
	简称重定向(302)
```



#### 创建路由层

---

不管你是用pycharm创建的应用，还是用命令行创建的应用，都不会自动生成 `urls.py` 。虽然你可以在项目容器下的 `urls.py` 里面声明视图函数，但是这样不便于后面管理。假设后期不使用你创建的应用层，对于你在项目容器下 `urls.py` 文件里面声明的这个应用相关的视图函数便没有了作用。

**以下是我推荐声明视图与路由相对应的方法**

首先在每个应用下创建路由层 `urls.py`（并与视图层存放同级目录下），然后在项目容器下的 `urls.py` 文件里面进行这些应用的 `urls.py` 导入。

```py
from django.conf.urls import url, include
from django.contrib import admin


urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^appname/$', include('appname.urls')),
]
```

关键就是函数 `include` 

​	`appname` 代表你创建的应用

​	`appname.urls` 代表你创建的应用下的 `urls.py` 文件

**注意：** 不同版本的Django，导入的接口不同。

还差最后一步我们就可以访问了。

在你创建的应用下的 `urls.py` 文件里面进行**视图与路由相对应**，这样我们才可以区别不同的网页。

```py
from django.conf.urls import url
from appname import views


urlpatterns = [
    url(r'index/', views.index),
]
```

可以使用 `http://127.0.0.1:8000/appname/index/` 进行访问。如果访问不了，可以重新启动服务器。

`http://127.0.0.1`：回送地址，你自己电脑的一个地址。

`8000`：端口，你自己电脑的一个端口号。

`appname/`：应用层，你在项目容器下的 `urls.py` 声明的路由层。

`index/`：路由层，你在应用下的 `urls.py` 声明的路由层。



**注意：**

> 像 http://127.0.0.1:8000/index/xxxx 或 http://127.0.0.1:8000/xxx/index/xxxx，这样的url，不经过处理的话，都会去访问首个注册的视图函数 index。
>
> 因此我们可以通过正则表达式里面的 **^限制开头** 、**$限制尾部**，如：`^index/$` 就不会有上面的问题。



#### 配置静态文件

---

我们需要在项目下创建目录 `static` ，当然这个名字可以修改，不然怎么创建多个静态文件目录呐。

在我们手动创建好一个 `static` 目录，我们还可以在它的下面创建 `js、css、html等` 目录方便管理文件，也可以直接将所有的静态文件放在这个目录下（不推荐这种方法）。当然我们需要配置一下路径，让它知道静态文件在哪里可以找到。

首先打开项目容器下的 `settings.py` 文件，

```py
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.11/howto/static-files/

STATIC_URL = '/static/'
```

找到上面这行代码，添加下面的代码，设置静态文件的路径，你可以设置多个静态目录到这个变量中。

```py
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
```

`'static'` 代表我们创建的静态文件目录。

当我们需要在 `.html` 文件里面导入静态文件 `css、js、image等` ，可以使用 `{% load static %}` 。

```py
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>index</title>
    {% load static %}
	# {% static path [as varname] %}
	<link rel="stylesheet" href="{% static '/css/bootstrap.min.css' %}">
</head>
<body>
Access the characters displayed by index {{ data }}
</body>
</html>
```

这里推荐一个下载静态文件源码的地方，[BOOTSTRAP](https://getbootstrap.com/docs/3.4/getting-started/#download)  https://getbootstrap.com/docs/3.4/getting-started/#download



#### 配置数据库

---

我的电脑安装了 `MySQL` 数据库，而使用 `MySQL` 数据库，用 Django 默认的模块 `mysqldb` 是会出错的。因此需要我们用 `pymysql` 来对 MySQL进行访问。

| Django version | MySQL version |
| :------------: | :-----------: |
|      1.11      | 5.5或5.5以上  |

我们可以使用代码导入这个模块到项目的库里面，并且使其代替MySQLdb。

代替方式就是在项目目录下的 `__init__.py` 输入以下代码：

```py
import pymysql
pymysql.install_as_MySQLdb()
```



##### ORM

> 对象关系映射

我们将类映射为表，对象映射为记录，对象属性映射为记录某个字段对应的值。

在每个应用目录下，都有一个 `models.py` 文件，我们在这个文件里面进行数据库对象的映射。

例如：

```py
from django.db import models

# Create your models here.


class User(models.Model):
    # id int primary_key auto_increment
    id = models.AutoField(primary_key=True)
    # username varchar(10)
    username = models.CharField(max_length=10, verbose_name='用户名')
    # passwd int
    passwd = models.IntegerField(verbose_name='密码')
    sex = models.CharField(max_length=5, default='boy', verbose_name='性别')
```

将上面的内容记录到 `migrations` 目录下。

```shell
python manage.py makemigrations
```

将 `migrations` 目录下的记录同步提交到数据库里面。

```py
python manage.py migrate
```

唯一的遗憾，就是每次的改动都需要执行这两个命令。

注意：在你的 `INSTALLED_APPS（settings.py）` 属性里面的应用注册，至少每个注册的应用都有一个数据库的表会生成。

|   功能   |                 命令                  |
| :------: | :-----------------------------------: |
| 数据更新 | models.User.objects.filter().update() |
| 数据查询 |     models.User.objects.filter()      |
| 数据添加 |     models.User.objects.create()      |



##### 数据的查询

当我们需要获取数据库的数据，我们需要导入拥有我们数据的 `model.py` 到视图层里面，这样我们就很方便的获取数据。

```py
from django.shortcuts import render
from root import models


def login(request):
    username = request.POST.get('username')
    passwd = request.POST.get('password')
    if username:	# 判断用户是否提交参数
        res = models.User.objects.filter(username=username)		# 进行数据筛选 
        # 打印结果 如果数据库的user表里面没有这个数据
        # 就会返回<QuerySet []>
        # 否则返回<QuerySet [<User: User object>]>
        print(res)	
    return render(request, 'root/login.html', locals())
    
```

首先我们通过判断 `username` 的值，来检测用户是否提交数据。当用户提交了 `username` 的值，那么我们通过 `models.User.objects.filter()` 来进行数据的查询，如果用户提交的 `username` 的值存在于数据库的 `user` 的表中，那么就返回相对应那行的值。



##### 数据的更新

```py
from django.shortcuts import render
from root import models


def updata(request):
	if request.method == 'POST':
        username = request.POST.get('username')
        passwd = request.POST.get('passwd')
        sex = request.POST.get('sex')
        res = models.User.objects.filter(username=username).update(
        	username=username,
        	passwd=passwd,
        	sex=sex
        )
    return render(request, 'root/register.html', locals())
```

 `update()` 更新表中数据。



##### 数据的添加

```py
from django.shortcuts import render
from root import models


# 第一种
def register(request):
    username = request.POST.get('username')
    passwd = request.POST.get('passwd')
    sex = request.POST.get('sex')
    if username:
        res = models.User.objects.create(username=username.decode('utf8'), passwd=int(passwd), sex=sex)
    return render(request, 'root/register.html', locals())
    

# 第二种
def register(request):
    username = request.POST.get('username')
    passwd = request.POST.get('passwd')
    sex = request.POST.get('sex')
    if username:	# 判断用户是否提交参数
    	res = models.User(username=username, passwd=passwd, sex=sex)
    	res.save()
    return render(request, 'root/register.html', locals())
```

如上代码中，`models.User.objects.create()` 为添加数据，实践上它是创建了一个对象，将对象添加到 `user` 表中。我们根据上面在 ORM 中代码得知： `passwd` 的属性数据类型为数字，`username` 的属性数据类型为字符串，`sex` 的数据默认的值为 `boy` （因为设置了 `default` ，指定 `null=True` 可以允许值为空值）。

注意：特殊符号我们需要解码一下，使其与数据库的字符集相对应。

**可能出现的报错**

- 网页请求参数的数据类型与数据库表中定义的数据类型不对应
- 网页请求参数的值的编码与数据库的字符集不对应
- 网页请求参数的值的长度超过数据库表中相对应的列名长度



##### 表与表的关系（外键）

我们可以利用外键来建立表与表之间的关系，建议将外键放在使用频率高的表中。

- 表一对一的关系

  ```py
  foreign_key = models.OneToOneField(to='RelationsTable')
  ```

- 表一对多的关系

  ```py
  foreign_key = models.ForeignKey(to='RelationsTable')
  ```

- 表多对多的关系

  ```py
  foreign_key = models.ManyToManyField(to='RelationsTable')
  ```



#### 反向解析

> 

**应用**

- 模板中的超链接

- 视图中的重定向

`urls.py`

```py
from django.conf.urls import url, include
from django.contrib import admin
from root import views


urlpatterns = [
	url(r'^admin/', admin.site.urls),
	url(r'^homw/', views.home, name='home'),
	url(r'^index/', views.index, name='index'),
]
```

**前端**

`index.html`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>index</title>
    <link href="https://cdn.bootcss.com/twitter-bootstrap/3.4.1/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<a href="{% url 'home' %}">跳转到home页面</a>
</body>
</html>
```

`{% url 'home' %}` 代表 `urls.py` 里面的 `name` 参数值为 `home` 的路由引用。

**后端**

**reverse()** 通过路由命名或可调用视图对象来生成路由地址的。

**resolve_url()** 通过路由命名或可调用视图对象来生成路由地址的。

`views.py`

```py
from django.shortcuts import render, HttpResponse, redirect, reverse, resolve_url


def index(request):
	print(reverse('home'))	# 获取路由地址
	print(resolve_url('home'))
    return render(request, 'index.html')
 
```

**注意：** 如果你定义的路由是带参式的，那么就需要指定参数，不指定是会报错的，具体方法可以查看看源码介绍。

```py
{% url "url_name" arg1 arg2 %}

or

{% url "url_name" name1=value1 name2=value2 %}
```

关于上面的描述，我们知道如果不同应用拥有相同的视图函数，并且在路由里面配置参数 `name` 相同时，可以利用空间命名来解决这个问题。

```py
from django.conf.urls import url, include
from django.contrib import admin


urlpatterns = [
	url(r'^admin/', admin.site.urls),
	url(r'^root/', include('root.urls', namespace='root')),
]

# 使用 'root:index'
```



#### 模板的继承与导入

##### 继承模板

```html
{% extends 'home.html' %}
```

##### 模块内部划分

```html
{% block name %}
	html语句、css语句、js语句都可以
{% endblock %}
```

`name` 模块划分的取名

##### 导入模板

```html
{% include 'name.html' %}
```



这两个方法可以方便地规划html的样式，以及优化代码。



#### 补充

---



##### 过滤器、标签

```py
{{ 参数|过滤器:过滤器参数 }}
{% 关键字 条件 %}
```

| 过滤器 | 作用 |
| :----: | :--: |
|        |      |

| 关键字 | 语法 | 作用 |
| :----: | :--: | :--: |
|        |      |      |



当然还可以自定义过滤器，在应用下创建 `templatetags` 文件夹，然后创建一个 `py` 文件且文件里面必须写两行固定代码

```py
from django import template
register = template.Library()
```

这样我们就可以用这个装饰器进行，过滤器的定义了。

```py
# @register.simple_tag(name='tag')
@register.filter(name='filter')
def filtered(*args):
	# 最多传两个参数，可以通过return返回结果
	...
```





##### 自动切换请求方法

当我们点击 `get` 请求页面里面的 `post` 请求时，就会自动处理。

`urls.py`

```py
from root import views


urlpatterns = [
	url(r'^login/', views.MyLogin.as_view())
]
```

`views.py`

```
from django.views import View


class MyLogin(View):
	def get(self, request):
		return render(request, 'index.html')
	
	def post(self, request):
		return render(request, 'home.html')
```

`base.py`

```py
def as_view(cls, **initkwargs):
	def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        if hasattr(self, 'get') and not hasattr(self, 'head'):
        	self.head = self.get
        self.request = request
        self.args = args
        self.kwargs = kwargs
        return self.dispatch(request, *args, **kwargs)
    return view


def dispatch(self, request, *args, **kwargs):
    if request.method.lower() in self.http_method_names:
    	handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
    else:
    	handler = self.http_method_not_allowed
    return handler(request, *args, **kwargs)
```







##### request

|   属性或方法    | 含义 |
| :-------------: | :--: |
|      body       |      |
|     method      |      |
|      path       |      |
|      FILES      |      |
|       GET       |      |
|      POST       |      |
| get_full_path() |      |



##### 数据传递

**直接传递json**

```py
from django.http import JsonResponse


def index(request):
    user = {
        'username': 'qaz',
        'password': '123',
        'sex': '男'
    }
    return JsonResponse(user)

```



##### 带参式路由

> 当我们的视图函数需要接受多个参数时，可以使用括号括起来。



**不指定参数名接收** 

`urls.py`

```py
from django.conf.urls import url, include
from django.contrib import admin


urlpatterns = [
	url(r'^admin/', admin.site.urls),
    url(r'^index/(\d+)/(\D+)', views.index),
    
]
```

`views.py` 

```py
from django.shortcuts import render


def index(requests, *args):
	print(args)
	...
```

当我在浏览器输入 `http://www.127.0.0.1:8000/index/123/qaz` 时，那么  **123**、**qaz** 这两个会作为参数传递给 `index` 函数，并且由 `*args` 接收。



**指定参数名接收**

`urls.py`

```py
from django.conf.urls import url, include
from django.contrib import admin


urlpatterns = [
	url(r'^admin/$', admin.site.urls),
    url(r'^index/(?P<year>\d+)/(?P<month>\d+)/(?P<day>\d+)/(?P<blog>/D+)', views.index),
]
```

`views.py`

```py
from django.shortcuts import render


def index(requests, **kwagrs):
	print(year, month, day, blog)
	...
```

当我在浏览器输入 `http://www.127.0.0.1:8000/index/2020/12/16/hello` 时，那么  **2020**、**12**、 **16**、**blog** 这四个会作为参数传递给 `index` 函数，并且由 `**kwagrs` 接收。

**注意：** 带参式路由的两种方法不能混合在一起使用。



##### 伪静态



##### 优化SEO





#### 文件系统

##### settings.py

```py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'appname.apps.AppnameConfig',
]
```

`INSTALLED_APPS:` 配置并注册应用

- [`django.contrib.admin`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/contrib/admin/index.html#module-django.contrib.admin) —— 管理站点
- [`django.contrib.auth`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/topics/auth/index.html#module-django.contrib.auth) —— 认证系统
- [`django.contrib.contenttypes`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/contrib/contenttypes.html#module-django.contrib.contenttypes) —— 用于内容类型的框架
- [`django.contrib.sessions`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/topics/http/sessions.html#module-django.contrib.sessions) —— 会话框架
- [`django.contrib.messages`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/contrib/messages.html#module-django.contrib.messages) —— 消息框架
- [`django.contrib.staticfiles`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/contrib/staticfiles.html#module-django.contrib.staticfiles) —— 管理静态文件的框架

在 `INSTALLED_APPS` 里面 `'appname.apps.AppnameConfig'` 是你创建的应用，需要在这个里面注册，从而加载到项目里面。

|      变量      |                             作用                             |
| :------------: | :----------------------------------------------------------: |
|  APPEND_SLASH  | 用户输入的网址尾部没有斜杠匹配不到内容时，是否加上斜杠再次匹配。 |
| INSTALLED_APPS |                           注册应用                           |



##### view.py

关于视图函数接收的参数 `request` ，可以获取请求参数。

|  参数  |             作用             |
| :----: | :--------------------------: |
| method |       获取用户请求方式       |
|  POST  | 获取用户提交的 POST 请求参数 |
|  GET   | 获取用户提交的 GET 请求参数  |

