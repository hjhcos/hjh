|  MD标记  |  HTML标记  | 功能       | 正则   |
| :------: | :--------: | ---------- | ------ |
|    #     |     h      | 目录、标题 | ^#+ .+ |
|    >     | blockquote | 区块、引用 |        |
|   ```    |    code    | 代码块     |        |
|    $$    |    code    | 数学公式   |        |
|   ---    |     hr     | 分割线     |        |
|   *、_   |     em     | 斜体       |        |
|   -、·   |   ul li    | 列表       |        |
|  **、__  |   strong   | 加粗       |        |
| ***、___ | strong em  | 加粗并斜体 |        |
|  ~~、--  |    del     | 删除线     |        |
|    `     |    code    | 高亮       |        |
|    $     |    code    | 数学公式   |        |
|   []()   |     a      | 链接       |        |
|    \|    |   table    | 表格       |        |

```
规则：
	#、>、|、---、- 、1. 开头不能含有其他字符，除了 --- 以外样式标记都可以用
	列表符号有一个空格才能识别
	$$、 ```换行识别开头不能有字符
- 有两种类型 功能 --- 样式 -- - 
样式标记：-、--、 ~~、 `、 *、 _
功能标记：---、$、 ` []() [][] [^] |
功能标记里面不能显示样式标签
样式标记里面可以显示功能标签

那么如何进行正确的匹配内容
	利用re.findall发现所有的匹配项
	利用上面定义的规则决定是否加载内容

那么如何更好处理嵌入在内容里面样式标记
	利用re.findall发现所有的匹配项
	再利用re.search获取匹配项的区域
	最后通过区域判别匹配项之间的关系层
	
那么如何友好处理功能标记
	首先进行正确功能标记的识别
	其次进行功能标记的区分

那么如何友好进行内容与标记的分割
	

那么如何写入样式以及规定class name id等
	这就可以利用配置文件
    [h]
    'class': ''
    'id': ''

    [a]
    'href': ''
```

### 检测标记

```python
# 第一种 获取标记的方式
# 将每一段的字符进行正则匹配 切割内容与标记
# 再进行正则匹配 一直直到没有符合的匹配项 （这种方法目前比较局限）

def detection(self, co=None):
    """ 主要处理一般标记"""
    if co:
        self.string = co
    while self.decide:
        for tag in self.RePattern:
            if self.patterns[tag][0].search(self.string):
                self.decide = False
                self.tag = self.patterns[tag]
                sub = self.tag[0].search(self.string)
                sub_index = sub.span()
                sub_text = sub.string[sub_index[0]:sub_index[1]]
                text = [sub.string[:sub_index[0]], sub.string[sub_index[1]:]]
                if text:
                    html = self.extract(sub_text)
                    self.string = html.join(text)
                else:
                    self.string = self.extract(sub_text)
                self.detection()
            if tag == self.RePattern[-1]:
                self.decide = False
    for tag in self.RePattern:
        if self.patterns[tag][0].search(self.string):
            self.decide = True
            self.detection()
```

```python
# 第二种 获取标记的方式
# 将定义的每个标记单独在整段数据里面循环识别 返回结果列表

def detection(self, data):
    """ 检测 ===》 样式标记检测"""
    # TODO: 检测标记是否有无结尾符
    # # > 已经做了处理不需要再进行处理
    for index, tag in enumerate(self.tags[2:]):
        if tag in data:
            matching = data.split(tag)
            length = 0
            pattern_list = [[None, None]]
            for match in matching:
                if match == '':
                    if (not pattern_list[-1][0]) and (not pattern_list[-1][1]):
                        pattern_list[-1][0] = tag
                    elif pattern_list[-1][1]:
                        # 对末尾标记进行处理
                        if not pattern_list[-1][0]:
                            pattern_list.append([tag*2, None])
                        elif len(pattern_list[-1][0]) == 1:
                            pattern_list.append([tag, None])
                        else:
                            length += 1
                            if length == len(pattern_list[-1][0])-1:
                                length = 0
                    else:
                        pattern_list[-1][0] += tag
                else:
                    if pattern_list[-1][1]:
                        if pattern_list[-1][0]:
                            pattern_list.append([None, match])
                        else:
                            pattern_list.append([tag, match])
                    else:
                        pattern_list[-1][1] = match
            pattern_list[-1] = [None, None]
            return pattern_list
```

```python
# 第三种 获取标记的方法
# 通过遍历数据的每一个字符与匹配字符是否相同
# 从而判断是否具有结尾符

def detection(self, string):
    """ 检测 ===》 样式标记检测"""
    print("MD.detection", string)
    # # > 已经做了处理不需要再进行处理
    match_tag = ''  # 当前标记
    matching = []   # 开始标记存放 待匹配
    matched = []    # 匹配到的标记
    start = 0   # 标记内部开头索引
    end = 0     # 标记内部结尾索引
    for index, char in enumerate(string):
        if char in self.tags[2:-2]:
            if not match_tag:
                match_tag = char
            elif char == match_tag[0]:
                match_tag += char
            else:
                start = index
                matching.append(match_tag)
                matching.append(start)
                match_tag = char
        else:
            if match_tag:
                if match_tag in matching:
                    start = matching.index(match_tag)
                    matching.pop(start)
                    temp = start
                    start = matching[start]
                    end = index - len(match_tag) - 1
                    matched.append([match_tag, (start, end)])
                    matching.pop(temp)
                    match_tag = ''
                else:
                    if match_tag:
                        start = index
                        matching.append(match_tag)
                        matching.append(start)
                        match_tag = ''

        pass
    if match_tag:
        if match_tag in matching:
            start = matching.index(match_tag)
            matching.pop(start)
            temp = start
            start = matching[start]
            end = len(string) - len(match_tag) - 1
            matched.append([match_tag, (start, end)])
            matching.pop(temp)
    self.division(matched)
    pass
```

```python

```

```python

```

